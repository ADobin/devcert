"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = require("fs");
const rimraf_1 = require("rimraf");
const debug_1 = tslib_1.__importDefault(require("debug"));
const constants_1 = require("./constants");
const platforms_1 = tslib_1.__importDefault(require("./platforms"));
const utils_1 = require("./utils");
const certificates_1 = require("./certificates");
const debug = debug_1.default('devcert:certificate-authority');
/**
 * Install the once-per-machine trusted root CA. We'll use this CA to sign
 * per-app certs.
 */
function installCertificateAuthority(options = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug(`Checking if older devcert install is present`);
        scrubOldInsecureVersions();
        debug(`Generating a root certificate authority`);
        let rootKeyPath = utils_1.mktmp();
        let rootCertPath = utils_1.mktmp();
        debug(`Generating the OpenSSL configuration needed to setup the certificate authority`);
        seedConfigFiles();
        debug(`Generating a private key`);
        certificates_1.generateKey(rootKeyPath);
        debug(`Generating a CA certificate`);
        utils_1.openssl(`req -new -x509 -config "${constants_1.caSelfSignConfig}" -key "${rootKeyPath}" -out "${rootCertPath}" -days 7000`);
        debug('Saving certificate authority credentials');
        yield saveCertificateAuthorityCredentials(rootKeyPath, rootCertPath);
        debug(`Adding the root certificate authority to trust stores`);
        yield platforms_1.default.addToTrustStores(rootCertPath, options);
    });
}
exports.default = installCertificateAuthority;
/**
 * Older versions of devcert left the root certificate keys unguarded and
 * accessible by userland processes. Here, we check for evidence of this older
 * version, and if found, we delete the root certificate keys to remove the
 * attack vector.
 */
function scrubOldInsecureVersions() {
    // Use the old verion's logic for determining config directory
    let configDir;
    if (constants_1.isWindows && process.env.LOCALAPPDATA) {
        configDir = path_1.default.join(process.env.LOCALAPPDATA, 'devcert', 'config');
    }
    else {
        let uid = process.getuid && process.getuid();
        let userHome = (constants_1.isLinux && uid === 0) ? path_1.default.resolve('/usr/local/share') : require('os').homedir();
        configDir = path_1.default.join(userHome, '.config', 'devcert');
    }
    // Delete the root certificate keys, as well as the generated app certificates
    debug(`Checking ${configDir} for legacy files ...`);
    [
        path_1.default.join(configDir, 'openssl.conf'),
        path_1.default.join(configDir, 'devcert-ca-root.key'),
        path_1.default.join(configDir, 'devcert-ca-root.crt'),
        path_1.default.join(configDir, 'devcert-ca-version'),
        path_1.default.join(configDir, 'certs')
    ].forEach((filepath) => {
        if (fs_1.existsSync(filepath)) {
            debug(`Removing legacy file: ${filepath}`);
            rimraf_1.sync(filepath);
        }
    });
}
/**
 * Initializes the files OpenSSL needs to sign certificates as a certificate
 * authority, as well as our CA setup version
 */
function seedConfigFiles() {
    // This is v2 of the devcert certificate authority setup
    fs_1.writeFileSync(constants_1.caVersionFile, '2');
    // OpenSSL CA files
    fs_1.writeFileSync(constants_1.opensslDatabaseFilePath, '');
    fs_1.writeFileSync(constants_1.opensslSerialFilePath, '01');
}
function withCertificateAuthorityCredentials(cb) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug(`Retrieving devcert's certificate authority credentials`);
        let tmpCAKeyPath = utils_1.mktmp();
        let tmpCACertPath = utils_1.mktmp();
        let caKey = yield platforms_1.default.readProtectedFile(constants_1.rootCAKeyPath);
        let caCert = yield platforms_1.default.readProtectedFile(constants_1.rootCACertPath);
        fs_1.writeFileSync(tmpCAKeyPath, caKey);
        fs_1.writeFileSync(tmpCACertPath, caCert);
        yield cb({ caKeyPath: tmpCAKeyPath, caCertPath: tmpCACertPath });
        fs_1.unlinkSync(tmpCAKeyPath);
        fs_1.unlinkSync(tmpCACertPath);
    });
}
exports.withCertificateAuthorityCredentials = withCertificateAuthorityCredentials;
function saveCertificateAuthorityCredentials(keypath, certpath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug(`Saving devcert's certificate authority credentials`);
        let key = fs_1.readFileSync(keypath, 'utf-8');
        let cert = fs_1.readFileSync(certpath, 'utf-8');
        yield platforms_1.default.writeProtectedFile(constants_1.rootCAKeyPath, key);
        yield platforms_1.default.writeProtectedFile(constants_1.rootCACertPath, cert);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VydGlmaWNhdGUtYXV0aG9yaXR5LmpzIiwic291cmNlUm9vdCI6IkQ6L2NvZGUvZGV2Y2VydC8iLCJzb3VyY2VzIjpbImNlcnRpZmljYXRlLWF1dGhvcml0eS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx3REFBd0I7QUFDeEIsMkJBS1k7QUFDWixtQ0FBd0M7QUFDeEMsMERBQWdDO0FBRWhDLDJDQVNxQjtBQUNyQixvRUFBMEM7QUFDMUMsbUNBQXlDO0FBQ3pDLGlEQUE2QztBQUc3QyxNQUFNLEtBQUssR0FBRyxlQUFXLENBQUMsK0JBQStCLENBQUMsQ0FBQztBQUUzRDs7O0dBR0c7QUFDSCxxQ0FBMEQsVUFBbUIsRUFBRTs7UUFDN0UsS0FBSyxDQUFDLDhDQUE4QyxDQUFDLENBQUM7UUFDdEQsd0JBQXdCLEVBQUUsQ0FBQztRQUUzQixLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQztRQUNqRCxJQUFJLFdBQVcsR0FBRyxhQUFLLEVBQUUsQ0FBQztRQUMxQixJQUFJLFlBQVksR0FBRyxhQUFLLEVBQUUsQ0FBQztRQUUzQixLQUFLLENBQUMsZ0ZBQWdGLENBQUMsQ0FBQztRQUN4RixlQUFlLEVBQUUsQ0FBQztRQUVsQixLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztRQUNsQywwQkFBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXpCLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBQ3JDLGVBQU8sQ0FBQywyQkFBNEIsNEJBQWlCLFdBQVksV0FBWSxXQUFZLFlBQWEsY0FBYyxDQUFDLENBQUM7UUFFdEgsS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7UUFDbEQsTUFBTSxtQ0FBbUMsQ0FBQyxXQUFXLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFFckUsS0FBSyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7UUFDL0QsTUFBTSxtQkFBZSxDQUFDLGdCQUFnQixDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNoRSxDQUFDO0NBQUE7QUF0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QUMsb0RBQW9ELENBQUMsQ0FBQztRQUM1RCxJQUFJLEdBQUcsR0FBRyxpQkFBUSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNyQyxJQUFJLElBQUksR0FBRyxpQkFBUSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN2QyxNQUFNLG1CQUFlLENBQUMsa0JBQWtCLENBQUMseUJBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM3RCxNQUFNLG1CQUFlLENBQUMsa0JBQWtCLENBQUMsMEJBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNqRSxDQUFDO0NBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHtcclxuICB1bmxpbmtTeW5jIGFzIHJtLFxyXG4gIHJlYWRGaWxlU3luYyBhcyByZWFkRmlsZSxcclxuICB3cml0ZUZpbGVTeW5jIGFzIHdyaXRlRmlsZSxcclxuICBleGlzdHNTeW5jIGFzIGV4aXN0c1xyXG59IGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgc3luYyBhcyByaW1yYWYgfSBmcm9tICdyaW1yYWYnO1xyXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnO1xyXG5cclxuaW1wb3J0IHtcclxuICByb290Q0FLZXlQYXRoLFxyXG4gIHJvb3RDQUNlcnRQYXRoLFxyXG4gIGNhU2VsZlNpZ25Db25maWcsXHJcbiAgb3BlbnNzbFNlcmlhbEZpbGVQYXRoLFxyXG4gIG9wZW5zc2xEYXRhYmFzZUZpbGVQYXRoLFxyXG4gIGlzV2luZG93cyxcclxuICBpc0xpbnV4LFxyXG4gIGNhVmVyc2lvbkZpbGVcclxufSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCBjdXJyZW50UGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybXMnO1xyXG5pbXBvcnQgeyBvcGVuc3NsLCBta3RtcCB9IGZyb20gJy4vdXRpbHMnO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZUtleSB9IGZyb20gJy4vY2VydGlmaWNhdGVzJztcclxuaW1wb3J0IHsgT3B0aW9ucyB9IGZyb20gJy4vaW5kZXgnO1xyXG5cclxuY29uc3QgZGVidWcgPSBjcmVhdGVEZWJ1ZygnZGV2Y2VydDpjZXJ0aWZpY2F0ZS1hdXRob3JpdHknKTtcclxuXHJcbi8qKlxyXG4gKiBJbnN0YWxsIHRoZSBvbmNlLXBlci1tYWNoaW5lIHRydXN0ZWQgcm9vdCBDQS4gV2UnbGwgdXNlIHRoaXMgQ0EgdG8gc2lnblxyXG4gKiBwZXItYXBwIGNlcnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaW5zdGFsbENlcnRpZmljYXRlQXV0aG9yaXR5KG9wdGlvbnM6IE9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xyXG4gIGRlYnVnKGBDaGVja2luZyBpZiBvbGRlciBkZXZjZXJ0IGluc3RhbGwgaXMgcHJlc2VudGApO1xyXG4gIHNjcnViT2xkSW5zZWN1cmVWZXJzaW9ucygpO1xyXG5cclxuICBkZWJ1ZyhgR2VuZXJhdGluZyBhIHJvb3QgY2VydGlmaWNhdGUgYXV0aG9yaXR5YCk7XHJcbiAgbGV0IHJvb3RLZXlQYXRoID0gbWt0bXAoKTtcclxuICBsZXQgcm9vdENlcnRQYXRoID0gbWt0bXAoKTtcclxuXHJcbiAgZGVidWcoYEdlbmVyYXRpbmcgdGhlIE9wZW5TU0wgY29uZmlndXJhdGlvbiBuZWVkZWQgdG8gc2V0dXAgdGhlIGNlcnRpZmljYXRlIGF1dGhvcml0eWApO1xyXG4gIHNlZWRDb25maWdGaWxlcygpO1xyXG5cclxuICBkZWJ1ZyhgR2VuZXJhdGluZyBhIHByaXZhdGUga2V5YCk7XHJcbiAgZ2VuZXJhdGVLZXkocm9vdEtleVBhdGgpO1xyXG5cclxuICBkZWJ1ZyhgR2VuZXJhdGluZyBhIENBIGNlcnRpZmljYXRlYCk7XHJcbiAgb3BlbnNzbChgcmVxIC1uZXcgLXg1MDkgLWNvbmZpZyBcIiR7IGNhU2VsZlNpZ25Db25maWcgfVwiIC1rZXkgXCIkeyByb290S2V5UGF0aCB9XCIgLW91dCBcIiR7IHJvb3RDZXJ0UGF0aCB9XCIgLWRheXMgNzAwMGApO1xyXG5cclxuICBkZWJ1ZygnU2F2aW5nIGNlcnRpZmljYXRlIGF1dGhvcml0eSBjcmVkZW50aWFscycpO1xyXG4gIGF3YWl0IHNhdmVDZXJ0aWZpY2F0ZUF1dGhvcml0eUNyZWRlbnRpYWxzKHJvb3RLZXlQYXRoLCByb290Q2VydFBhdGgpO1xyXG5cclxuICBkZWJ1ZyhgQWRkaW5nIHRoZSByb290IGNlcnRpZmljYXRlIGF1dGhvcml0eSB0byB0cnVzdCBzdG9yZXNgKTtcclxuICBhd2FpdCBjdXJyZW50UGxhdGZvcm0uYWRkVG9UcnVzdFN0b3Jlcyhyb290Q2VydFBhdGgsIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogT2xkZXIgdmVyc2lvbnMgb2YgZGV2Y2VydCBsZWZ0IHRoZSByb290IGNlcnRpZmljYXRlIGtleXMgdW5ndWFyZGVkIGFuZFxyXG4gKiBhY2Nlc3NpYmxlIGJ5IHVzZXJsYW5kIHByb2Nlc3Nlcy4gSGVyZSwgd2UgY2hlY2sgZm9yIGV2aWRlbmNlIG9mIHRoaXMgb2xkZXJcclxuICogdmVyc2lvbiwgYW5kIGlmIGZvdW5kLCB3ZSBkZWxldGUgdGhlIHJvb3QgY2VydGlmaWNhdGUga2V5cyB0byByZW1vdmUgdGhlXHJcbiAqIGF0dGFjayB2ZWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBzY3J1Yk9sZEluc2VjdXJlVmVyc2lvbnMoKSB7XHJcbiAgLy8gVXNlIHRoZSBvbGQgdmVyaW9uJ3MgbG9naWMgZm9yIGRldGVybWluaW5nIGNvbmZpZyBkaXJlY3RvcnlcclxuICBsZXQgY29uZmlnRGlyOiBzdHJpbmc7XHJcbiAgaWYgKGlzV2luZG93cyAmJiBwcm9jZXNzLmVudi5MT0NBTEFQUERBVEEpIHtcclxuICAgIGNvbmZpZ0RpciA9IHBhdGguam9pbihwcm9jZXNzLmVudi5MT0NBTEFQUERBVEEsICdkZXZjZXJ0JywgJ2NvbmZpZycpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgdWlkID0gcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKTtcclxuICAgIGxldCB1c2VySG9tZSA9IChpc0xpbnV4ICYmIHVpZCA9PT0gMCkgPyBwYXRoLnJlc29sdmUoJy91c3IvbG9jYWwvc2hhcmUnKSA6IHJlcXVpcmUoJ29zJykuaG9tZWRpcigpO1xyXG4gICAgY29uZmlnRGlyID0gcGF0aC5qb2luKHVzZXJIb21lLCAnLmNvbmZpZycsICdkZXZjZXJ0Jyk7XHJcbiAgfVxyXG5cclxuICAvLyBEZWxldGUgdGhlIHJvb3QgY2VydGlmaWNhdGUga2V5cywgYXMgd2VsbCBhcyB0aGUgZ2VuZXJhdGVkIGFwcCBjZXJ0aWZpY2F0ZXNcclxuICBkZWJ1ZyhgQ2hlY2tpbmcgJHsgY29uZmlnRGlyIH0gZm9yIGxlZ2FjeSBmaWxlcyAuLi5gKTtcclxuICBbXHJcbiAgICBwYXRoLmpvaW4oY29uZmlnRGlyLCAnb3BlbnNzbC5jb25mJyksXHJcbiAgICBwYXRoLmpvaW4oY29uZmlnRGlyLCAnZGV2Y2VydC1jYS1yb290LmtleScpLFxyXG4gICAgcGF0aC5qb2luKGNvbmZpZ0RpciwgJ2RldmNlcnQtY2Etcm9vdC5jcnQnKSxcclxuICAgIHBhdGguam9pbihjb25maWdEaXIsICdkZXZjZXJ0LWNhLXZlcnNpb24nKSxcclxuICAgIHBhdGguam9pbihjb25maWdEaXIsICdjZXJ0cycpXHJcbiAgXS5mb3JFYWNoKChmaWxlcGF0aCkgPT4ge1xyXG4gICAgaWYgKGV4aXN0cyhmaWxlcGF0aCkpIHtcclxuICAgICAgZGVidWcoYFJlbW92aW5nIGxlZ2FjeSBmaWxlOiAkeyBmaWxlcGF0aCB9YClcclxuICAgICAgcmltcmFmKGZpbGVwYXRoKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIHRoZSBmaWxlcyBPcGVuU1NMIG5lZWRzIHRvIHNpZ24gY2VydGlmaWNhdGVzIGFzIGEgY2VydGlmaWNhdGVcclxuICogYXV0aG9yaXR5LCBhcyB3ZWxsIGFzIG91ciBDQSBzZXR1cCB2ZXJzaW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBzZWVkQ29uZmlnRmlsZXMoKSB7XHJcbiAgLy8gVGhpcyBpcyB2MiBvZiB0aGUgZGV2Y2VydCBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgc2V0dXBcclxuICB3cml0ZUZpbGUoY2FWZXJzaW9uRmlsZSwgJzInKTtcclxuICAvLyBPcGVuU1NMIENBIGZpbGVzXHJcbiAgd3JpdGVGaWxlKG9wZW5zc2xEYXRhYmFzZUZpbGVQYXRoLCAnJyk7XHJcbiAgd3JpdGVGaWxlKG9wZW5zc2xTZXJpYWxGaWxlUGF0aCwgJzAxJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyhjYjogKHsgY2FLZXlQYXRoLCBjYUNlcnRQYXRoIH06IHsgY2FLZXlQYXRoOiBzdHJpbmcsIGNhQ2VydFBhdGg6IHN0cmluZyB9KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZCkge1xyXG4gIGRlYnVnKGBSZXRyaWV2aW5nIGRldmNlcnQncyBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgY3JlZGVudGlhbHNgKTtcclxuICBsZXQgdG1wQ0FLZXlQYXRoID0gbWt0bXAoKTtcclxuICBsZXQgdG1wQ0FDZXJ0UGF0aCA9IG1rdG1wKCk7XHJcbiAgbGV0IGNhS2V5ID0gYXdhaXQgY3VycmVudFBsYXRmb3JtLnJlYWRQcm90ZWN0ZWRGaWxlKHJvb3RDQUtleVBhdGgpO1xyXG4gIGxldCBjYUNlcnQgPSBhd2FpdCBjdXJyZW50UGxhdGZvcm0ucmVhZFByb3RlY3RlZEZpbGUocm9vdENBQ2VydFBhdGgpO1xyXG4gIHdyaXRlRmlsZSh0bXBDQUtleVBhdGgsIGNhS2V5KTtcclxuICB3cml0ZUZpbGUodG1wQ0FDZXJ0UGF0aCwgY2FDZXJ0KTtcclxuICBhd2FpdCBjYih7IGNhS2V5UGF0aDogdG1wQ0FLZXlQYXRoLCBjYUNlcnRQYXRoOiB0bXBDQUNlcnRQYXRoIH0pO1xyXG4gIHJtKHRtcENBS2V5UGF0aCk7XHJcbiAgcm0odG1wQ0FDZXJ0UGF0aCk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNhdmVDZXJ0aWZpY2F0ZUF1dGhvcml0eUNyZWRlbnRpYWxzKGtleXBhdGg6IHN0cmluZywgY2VydHBhdGg6IHN0cmluZykge1xyXG4gIGRlYnVnKGBTYXZpbmcgZGV2Y2VydCdzIGNlcnRpZmljYXRlIGF1dGhvcml0eSBjcmVkZW50aWFsc2ApO1xyXG4gIGxldCBrZXkgPSByZWFkRmlsZShrZXlwYXRoLCAndXRmLTgnKTtcclxuICBsZXQgY2VydCA9IHJlYWRGaWxlKGNlcnRwYXRoLCAndXRmLTgnKTtcclxuICBhd2FpdCBjdXJyZW50UGxhdGZvcm0ud3JpdGVQcm90ZWN0ZWRGaWxlKHJvb3RDQUtleVBhdGgsIGtleSk7XHJcbiAgYXdhaXQgY3VycmVudFBsYXRmb3JtLndyaXRlUHJvdGVjdGVkRmlsZShyb290Q0FDZXJ0UGF0aCwgY2VydCk7XHJcbn1cclxuIl19